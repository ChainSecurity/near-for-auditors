{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>This document aims to be an introduction to the NEAR protocol for advanced users. Its main purpose is for users to acquire adequate knowledge in order to understand how the protocol works under the hood, and thus predict the behavior of smart contracts to either avoid common pitfalls in their development or detect issues in their review.</p>"},{"location":"#requirements","title":"Requirements:","text":"<ul> <li>Familiarity with Rust</li> <li>Familiarity with blockchain concepts</li> </ul>"},{"location":"#prelude","title":"Prelude","text":"<p>In this section, we present some tools which are used in the tutorials.</p>"},{"location":"#expanding-macros","title":"Expanding macros","text":"<p>Currently, all contracts used as an example are written in Rust. Rust makes extensive use of macros which allows users to avoid writing boilerplate code. Macros are expanded before compilation. This means that the code written by users can look quite different from the code which is actually compiled. We strongly recommend users who want to dive deep into NEAR protocol to also review the code produced after the macro expansion. The compiler of Rust already provides such a functionality with the following command:</p> <p><code>cargo rustc --profile=check -- -Zunpretty=expanded</code></p> <p>An alternative which provides a better UX is <code>cargo expand</code>. After building your project use the following command:</p> <p><code>cargo expand --target-dir &lt;your-project-dir&gt; --target wasm32-unknown-unknown</code></p>"},{"location":"#inspecting-wasm","title":"Inspecting WASM","text":"<p>Smart contracts are compiled to WebAssembly (WASM) and then stored and executed in this format. WASM is a binary format and thus not human-readable. Users who want to inspect WASM code should use a tool such as <code>wasm2wat</code> in order to convert the binary format to a human readable text format.</p>"},{"location":"basics/","title":"Basics","text":"<p>NEAR introduces a lot of new concepts with which auditors and developers might not be familiar. A quick introduction to those can be found here. In this section we define the most important of them:</p>"},{"location":"basics/#accounts","title":"Accounts","text":"<p>Accounts are similar to Ethereum's public addresses in the sense that they can initiate transactions and store contracts. However, they differ a lot from their Ethereum counterparts in the following ways:</p> <ul> <li>Each account has a human readable name in the form of <code>[&lt;subdomain&gt;.]*near</code>. In Ethereum, public addresses are associated with a hexadecimal number by default. There are protocols that can wrap these addresses to human-readable names but these require extra steps from the users.</li> <li>Multiple public keys can sign transactions for one account using the corresponding private keys. These public keys are called Full Access Keys. They can sign all kinds of transactions on behalf of one account.</li> <li>Public keys can have limited access to an account Function Call Keys. These keys are allowed to make a specific function calls to a specific account and spend a limited amount of NEAR tokens stored in the account. A formal specification of the concept can be found here.</li> <li>An account can store a contract and still operate as a normal user account. This means that even if an account contains a contract, it can still make arbitrary calls to other contracts, since it is controlled by any users who have a Full Access Key to the account.</li> </ul>"},{"location":"basics/#actions","title":"Actions","text":"<p>Actions are a unit of operation on the NEAR blockchain. Multiple Actions can be batched in one transaction. Formally they are defined here. For completeness, we enumerate them here and give a short description. We dive deeper into some of them in other tutorials.</p> <ul> <li><code>CreateAccount</code>: Creates a new account id.</li> <li><code>DeployContract</code>: Deploys a contract under an account id.</li> <li><code>FunctionCall</code>: Makes a call to a method of a contract stored under an account id.</li> <li><code>Transfer</code>: Transfers NEAR to an account id.</li> <li><code>Stake</code>: Stakes NEAR for a validator.</li> <li><code>AddKey</code>: Adds a public key (either Full Access or Function Call) to an account id.</li> <li><code>DeleteKey</code>: Deletes a public key from an account.</li> <li><code>DeleteAccount</code>: Deletes an account.</li> </ul>"},{"location":"basics/#transactions","title":"Transactions","text":"<p>A transaction is a batch of actions which is signed by a user who controls the private key of one of the whitelisted public keys for the account sending the transaction.</p>"},{"location":"basics/#receipts","title":"Receipts","text":"<p>Receipts implement cross-contract communication. They can only be created by nodes which are responsible for producing parts of the block from a shard (chunk producers). There are two types of them: </p> <ol> <li> <p>Action Receipts, which specify an action to be executed and </p> </li> <li> <p>Data Receipts, which represent the result of a call to a contract. These are, essentially, the input data which an Action Receipt expects before it can be processed.</p> </li> </ol>"},{"location":"basics/#environment","title":"Environment","text":"<p>The environment is the part of the state of the blockchain that a function call can access during its execution.</p>"},{"location":"basics/#promises","title":"Promises","text":"<p>Promises are the interface used by <code>near-sdk</code> to create asynchronous calls and process their results.</p>"},{"location":"basics/#runtime","title":"Runtime","text":"<p>Runtime is an overloaded term. It can refer to either:</p> <ul> <li>The runtime layer, which is used to execute smart contracts and other actions created by the users and preserve the state between the executions. </li> <li>The virtual machine that executes the WebAssembly representation of a contract.</li> </ul>"},{"location":"basics/#host","title":"Host","text":"<p>The host is the application which executes the runtime layer. It calls into the WASM binary and receives the calls to the environment.</p>"},{"location":"cross-contract-calls/","title":"Cross-contract Calls","text":"<p>Let us consider the example of a contract that implements some cross-contract calls. Users should be already familiar with how simple executions take place in the runtime.</p>"},{"location":"cross-contract-calls/#external-contract-interfaces","title":"External Contract interfaces","text":"<p>The first thing we need to observe is the definition of <code>ExtCrossContract</code>. Similarly to Solidity, in order for the smart contract to typecheck, we need to define the interface of the external contracts we wish to interact with. In Rust, this happens with a declaration of a trait such as <code>ExtCrossContract</code>. In this particular case, <code>ExtCrossContract</code> implements four functions, namely <code>a</code> which takes no arguments and returns a Promise, i.e. it makes another cross-contract call; <code>b</code> which takes a <code>bool</code> parameter and returns a <code>String</code>; <code>c</code> which takes and returns a <code>u8</code>; and <code>handle_callback</code> which takes three callback results and returns three booleans.</p> <pre><code>#[ext_contract(ext)]\npub trait ExtCrossContract {\nfn a() -&gt; Promise;\nfn b(fail: bool) -&gt; String;\nfn c(value: u8) -&gt; u8;\nfn handle_callbacks(\n#[callback_result] a: Result&lt;u8, PromiseError&gt;,\n#[callback_result] b: Result&lt;String, PromiseError&gt;,\n#[callback_result] c: Result&lt;u8, PromiseError&gt;,\n) -&gt; (bool, bool, bool);\n}\n</code></pre>"},{"location":"cross-contract-calls/#expanding-ext_contractext","title":"Expanding <code>#[ext_contract(ext)]</code>","text":"<p>In order to understand the role this trait declaration plays in the execution we need to see the expanded code with <code>cargo-expand</code>:</p> <pre><code>pub mod ext {\n...\npub fn c(\nvalue: u8,\n__account_id: AccountId,\n__balance: near_sdk::Balance,\n__gas: near_sdk::Gas,\n) -&gt; near_sdk::Promise {\n#[serde(crate = \"near_sdk::serde\")]\nstruct Input {\nvalue: u8,\n}\n#[doc(hidden)]\n#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]\nconst _: () = {...};\nlet args = Input { value };\nlet args = near_sdk::serde_json::to_vec(&amp;args)\n.expect(\"Failed to serialize the cross contract args using JSON.\");\nnear_sdk::Promise::new(__account_id).function_call(\"c\".to_string(), args, __balance, __gas)\n}\n\n...\n}\n</code></pre> <p>The trait turns into a module which is essentially a Promise factory. A Promise is just a <code>FunctionCall</code> action with some arguments. When you pass an argument to <code>c</code>, it needs to be serialized, so it is important for the factory to know that it expects an argument. It is important to note, however, that arguments annotated with <code>#[callback_result]</code> are essentially ignored since they do not need be passed. This means that we could omit them. Later we will see how the promise results are handled by the runtime.</p> <p>The expanded version of <code>ExtCrossContract</code> gives us a hint about the API for a cross-contract call. Except for the actual arguments to the call function, e.g. <code>value</code> in the case of <code>c</code>, we need to specify the <code>__account_id</code>, which is the id of the account to receive the call; the <code>__balance</code> which is the number of NEAR tokens we pass/transfer in the call; and the <code>__gas</code> which is the amount of gas to provide for this call to execute.</p> <p>If we inspect <code>a</code> we will see the following:</p> <pre><code>pub fn a() -&gt; Promise {\next::c(\nA_VALUE,\nenv::current_account_id(),\n0,\nenv::prepaid_gas() / 2,\n)\n}\n</code></pre> <p>Indeed, in order to make a cross contract call we call a function from <code>ext</code> module and we pass the arguments as discussed.</p>"},{"location":"cross-contract-calls/#promises","title":"Promises","text":"<p>Cross-contract calls are implemented with Promises. Promises are just action receipts to another or the same shard. A function call that makes a cross-contract call must return a <code>Promise</code>. However, an action receipt might need to wait some time before it executes. The Promise API is used in that case. When the promise is returned to the runtime after a function call, the runtime will create the corresponding action receipts and send them to the appropriate shards. Then, when the action receipt has no data receipts pending, it will execute. For example, consider the receipts which are created here. Four action receipts will be created one for each promise namely the calls <code>ext::a</code>, <code>ext::b</code>, <code>ext::c</code>, <code>ext::handle_callback</code>. The first three receipts have no dependencies. The last, however, does. This means that 3 data receipts will be created. Moreover, note that the first call (<code>a</code>) will eventually make another cross-contract call.</p> <pre><code>ext::a(env::current_account_id(), 0, gas_per_promise)\n.and(ext::b(fail_b, env::current_account_id(), 0, gas_per_promise))\n.and(ext::c(c_value, env::current_account_id(), 0, gas_per_promise))\n.then(ext::handle_callbacks(env::current_account_id(), 0, gas_per_promise))\n</code></pre> <p>All of the above are summarized in the following diagram:</p> <p> </p> <p>In Figure I. we show how the calls would be executed to arbitrary contracts. However, in this particular case, all calls are made to the contract itself; thus, they will be executed in the same shard as shown in Figure II. (click on the figure to zoom)</p> <p>As soon as there are no pending data receipts, <code>handle_callback</code> will be executed. <code>handle_callbacks</code> has the following definition:</p> <pre><code>pub fn handle_callbacks(\n#[callback_unwrap] a: u8,\n#[callback_result] b: Result&lt;String, PromiseError&gt;,\n#[callback_result] c: Result&lt;u8, PromiseError&gt;,\n) -&gt; (bool, bool) {\nrequire!(a == A_VALUE, \"Promise returned incorrect value\");\nif let Ok(s) = b.as_ref() {\nrequire!(s == \"Some string\");\n}\n(b.is_err(), c.is_err())\n}\n</code></pre> <p>It takes the results of three promises as arguments. This means that it will try to read these results from the execution environment (<code>env</code>). As soon as all the dependencies are satisfied, the following method will be executed by the runtime.</p> <p>Let us inspect part of the expanded version of the definition of <code>handle_callbacks</code>:</p> <pre><code>pub extern \"C\" fn handle_callbacks() {\nnear_sdk::env::setup_panic_hook();\n...\nlet a: u8 =\nnear_sdk::serde_json::from_slice(&amp;data).expect(\"Failed to deserialize callback using JSON\");\nlet b: Result&lt;String, PromiseError&gt; = match near_sdk::env::promise_result(1u64) {\nnear_sdk::PromiseResult::Successful(data) =&gt; Ok(near_sdk::serde_json::from_slice(&amp;data)\n.expect(\"Failed to deserialize callback using JSON\")),\nnear_sdk::PromiseResult::NotReady =&gt; Err(near_sdk::PromiseError::NotReady),\nnear_sdk::PromiseResult::Failed =&gt; Err(near_sdk::PromiseError::Failed),\n};\nlet c: Result&lt;u8, PromiseError&gt; = match near_sdk::env::promise_result(2u64) {\nnear_sdk::PromiseResult::Successful(data) =&gt; Ok(near_sdk::serde_json::from_slice(&amp;data)\n.expect(\"Failed to deserialize callback using JSON\")),\nnear_sdk::PromiseResult::NotReady =&gt; Err(near_sdk::PromiseError::NotReady),\nnear_sdk::PromiseResult::Failed =&gt; Err(near_sdk::PromiseError::Failed),\n};\nlet result = Callback::handle_callbacks(a, b, c);\nlet result = near_sdk::serde_json::to_vec(&amp;result)\n.expect(\"Failed to serialize the return value using JSON.\");\nnear_sdk::env::value_return(&amp;result);\n}\n</code></pre> <p>What we see here is that the call will try to read the first three promise results from the environment, parse them and then execute the logic inside <code>handle_callbacks</code>. This also explains why we don't need to pass any arguments when we create the call to <code>handle_callbacks</code>. </p> <p>It is important to note that the runtime is not aware of the promise dependencies of the call during the execution of the call. In other words, the action receipt would wait for the three calls to execute even if it would make use of only two of them.  Conversely, an action receipt waiting for 2 data receipts could execute even if the method it executes takes three promise arguments. Whether the correct dependencies are satisfied is the responsibility of the developer. Moreover we need to emphasize the \"random\" nature of the execution in a concurrent environment. There are no guarantees about the order of execution of cross-contract calls. Developers should explicitly define the order of execution if required, using the Promise API. For example, there are no guarantees provided by the specification of the protocol that the following cross-contract calls(<code>a()</code>, <code>b(fail_b)</code>, <code>c(c_value)</code>) aiming the same shard will executed in that order as given in the snippet below:</p> <pre><code>ext::a(env::current_account_id(), 0, gas_per_promise)\n.and(ext::b(fail_b, env::current_account_id(), 0, gas_per_promise))\n.and(ext::c(c_value, env::current_account_id(), 0, gas_per_promise))\n</code></pre> <p>Another important point is the return value of an external call. In a trustless environment, an external call might not fully satisfy the assumed interface. In other words, a call to an external contract might return a different type than expected. This would lead the callback to fail. For example, consider a cross contract call to a contract which satisfies the interface of ExtCrossContract except for the return value of <code>b</code> for which it instead returns a String. When the callback tries to process the result of the Promise, it will fail.</p>"},{"location":"cross-contract-calls/#the-private-macro","title":"The <code>#[private]</code> macro","text":"<p>The <code>#[private]</code> macro specifies that a function can only be externally called by the contract itself. In its expanded version, it looks like this:</p> <pre><code>    if near_sdk::env::current_account_id() != near_sdk::env::predecessor_account_id() {\nnear_sdk::env::panic_str(\"Method handle_callbacks is private\");\n}\n</code></pre> <p>This allows the restriction of access to callback functions to prevent external contracts from injecting data into a function that is expected to be called by the contract itself. Note that a \"private\" function must still be defined as a <code>pub fn</code>, which allows it to be called externally!</p>"},{"location":"cross-contract-calls/#storage-in-cross-contract-calls","title":"Storage in Cross-contract Calls","text":"<p>As we have discussed, in contrast to Ethereum where transactions are executed atomically, in NEAR only Action Receipts are executed atomically. As we have showed in this tutorial, cross-contract calls create new Action Receipts.</p> <p>Let us consider the case where any of the calls of the <code>call_all</code> method failed. The failure of the cross-contract call, e.g., <code>a</code>, would lead to reverting the storage modification performed by <code>a</code> only. However, the modification caused by <code>call_all</code> would not be reverted. Moreover, <code>handle_callback</code> is indifferent of whether any of the external calls it awaits failed. As soon as all the external calls are executed, <code>handle_callback</code> can also execute. If we want to revert the changes of <code>call_all</code>, we should do it manually in <code>handle_callback</code>. At this point we want to draw the reader's attention to two important points:</p> <ol> <li>Each contract is responsible for reverting its own state. Thus, failures of cross-contract calls should be handled manually.</li> <li>To revert the storage manually, the action needs to have enough gas. This should also be guaranteed by the implementation.</li> </ol> <p>The NEAR runtime does not prevent a second call to the same contract method from executing while the first one waits for its dependencies. This means that any modification of the first method call will be visible in the second one. For example, the following scenario is possible:</p> <ol> <li>User <code>A</code> makes a call to method <code>a</code> of contract <code>C</code> which modifies the state of the contract. <code>a</code> makes a cross-contract call and uses a callback <code>ca</code> to handle the result of the cross-contract call.</li> <li><code>ca</code> awaits the completion of the cross-contract call</li> <li>User <code>B</code> makes a call to method <code>a</code> of <code>C</code>. This execution will use the updated state from 1.</li> </ol> <p>The Figure below illustrates the example:</p> <p> </p>"},{"location":"deployment/","title":"Deployment","text":"<p>Deploying a contract takes a few steps. These can either be done in a batch transaction or individually. One thing is for sure, we need to store the contract under an account id. For that we might need to create a new account.</p>"},{"location":"deployment/#creating-an-account","title":"Creating an account","text":"<p>First, we need to create an account for our contract. We can do this by submitting a <code>CreateAccount</code>action in a transaction. Additionally, we must either deploy a contract in the same batch transaction, or create an full access key so we can deploy it later.</p> <pre><code>CreateAccountAction {}\n</code></pre> <p>All transactions define a predecessor, i.e., the account id which creates this transaction. <code>CreateAccountAction</code> can only create accounts for this predecessor. For example <code>alice.near</code> can create accounts of the form <code>&lt;subdomain&gt;.alice.near</code>. A top level account e.g., <code>alice.near</code> can only be created by the registrar. The <code>CreateAccount</code> action does not contain any data, as it uses the receiver address of the Transaction or ActionReceipt within which it is contained.</p> <p>After creating a new account, all subsequent actions in the same batch transaction will be executed on behalf of the new account. In NEAR's terms the predecessor of all the ActionReceipts following a CreateAccountAction is the new account id.</p>"},{"location":"deployment/#deploying-a-contract","title":"Deploying a contract","text":"<p>To deploy new code to an account, you need to have the authority to do so, which means having a full access key or allowing the contract itself to deploy its code. You can do this by submitting a <code>DeployContract</code> action that includes the contract's bytecode. This action replaces any existing code with the new bytecode you submitted.</p> <p>If you want to update the code of an existing contract, you can deploy new code to it again. However, if you want to make sure that the contract is not modified after it has been deployed, you need to remove all Full Access Keys. Also, the contract should not be able to deploy code to itself in an untrusted manner.</p> <p>It's worth noting that there is a limit to how much code can be deployed to a contract, which is determined by the genesis configuration. The current limit is 4194304 bytes (2^22).</p> <p>The <code>DeployContractAction</code> is simply the action you take to deploy the new code, and it follows a specific format.</p> <pre><code>DeployContractAction {\ncode: Vec&lt;u8&gt;\n}\n</code></pre> <p>The contract is deployed and ready to use as soon as the action finishes.</p> <p>It is important to emphasize that there are no limitations on how many <code>DeployContract</code> actions exist in a batch. For example, we could have a batch that looks like: </p> <ol> <li>Deploy a contract</li> <li>Function call on that contract</li> <li>Deploy a new contract to that location</li> </ol>"},{"location":"deployment/#initialization","title":"Initialization","text":"<p>If a contract has methods that either view or modify the contract's state (which is represented by the <code>&amp;self</code> or <code>&amp;mut self</code> arguments), it needs to implement the <code>Default</code> trait. This is because when any method is called on the contract, a default state will be created if the contract state does not already exist.</p> <p>If you don't want a default state to be created, you can instead use the <code>PanicOnDefault</code> trait. As the name suggests, this trait will cause the program to panic when <code>default</code> is called.</p> <p>To implement the <code>Default</code> trait, you can either use the <code>derive</code> macro or manually write the implementation yourself.</p> <p>For StatusMessage contract we derive the trait using a Rust macro:</p> <pre><code>use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};\nuse near_sdk::{near_bindgen, AccountId};\nuse std::collections::HashMap;\n\n#[derive(Default, BorshDeserialize, BorshSerialize)]\npub struct StatusMessage {\nrecords: HashMap&lt;AccountId, String&gt;,\n}\n</code></pre> <p>For TestContract we implement it ourselves:</p> <pre><code>use near_sdk::near_bindgen;\n\npub struct TestContract {}\n\nimpl Default for TestContract {\nfn default() -&gt; Self {\nSelf {}\n}\n}\n\n#[near_bindgen]\nimpl TestContract {\n#[init]\npub fn new() -&gt; Self {\nSelf {}\n}\n}\n</code></pre> <p>The <code>#[init]</code> decorator allows us to write a function that returns an instance of the contract state, which is then written to storage. This allows us to initialize the contract. By default, <code>#[init]</code> panics if the state already exists, but we can instead use <code>#[init(ignore_state)]</code> if the function should be able to be called multiple times. In order to call an init method, we just submit a transaction with a FunctionCall action. We discuss FunctionCalls here in more detail. An init method may take arguments and is not called automatically. If we call a different function before the <code>#[init]</code> function, the contract's <code>Default</code> implementation will be called. Therefore, if we want to enforce calling of the <code>#[init]</code> function, we should derive the <code>PanicOnDefault</code> trait, or simply replace the <code>Default</code> implementation with our desired functionality.</p>"},{"location":"deployment/#all-together-now","title":"All together now","text":"<p>Putting it all together, we could submit a transaction containing a batch of actions as follows:</p> <pre><code>actions: [\nCreateAccountAction {},\nAddKeyAction { \"public_key\": \"...\", \"access_key\": \"...\" },\nDeployContractAction { \"code\": \"...\" },\nFunctionCall { gas: 100000, deposit: 0, method_name: \"init\", args: \"{'hello_world'}\" }\n],\n</code></pre> <p>This batch would then execute atomically, so even if the init method were to fail, we wouldn't be left with a misconfigured contract. Later, we can upgrade the contract by using the access key we created, assuming we configured it to have full access.</p>"},{"location":"execution/","title":"Function Calls to Contracts","text":"<p>Let's consider the StatusMessage contract:</p> <pre><code>use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};\nuse near_sdk::{\nenv, near_bindgen, AccountId, collections\n};\nuse near_sdk::store::UnorderedMap;\n\n\n#[near_bindgen]\n#[derive(Default, BorshDeserialize, BorshSerialize)]\npub struct StatusMessage {\nrecords: UnorderedMap&lt;AccountId, String&gt;,\n}\n\n#[near_bindgen]\nimpl StatusMessage {\n\n#[init]\npub fn new() -&gt; Self {\n// Initializing `status_updates` with unique key prefix.\nSelf {\nrecords: UnorderedMap::new(b\"r\".to_vec()),\n}\n}\n\n#[payable]\npub fn set_status(&amp;mut self, message: String) {\nlet account_id = env::predecessor_account_id();\nlog!(\"{} set_status with message {}\", account_id, message);\nself.records.insert(account_id, message);\n}\n\npub fn get_status(&amp;self, account_id: AccountId) -&gt; Option&lt;String&gt; {\nlog!(\"get_status for account_id {}\", account_id);\nself.records.get(&amp;account_id).cloned()\n}\n}\n</code></pre> <p>The state of the contract consists of a <code>UnorderedMap</code> from <code>AccountId</code> to <code>String</code>. Note that <code>UnorderedMap</code> is part of the <code>near_sdk</code> library. For now we can think of it as the equivalent to the <code>HashMap</code> in the Rust (<code>std</code>) standard library. We will discuss later the differences between <code>near_sdk::store::UnorderedMap</code> and <code>std::collections::HashMap</code>.</p> <p>The contract exposes three public functions (indicated with <code>pub</code>), namely <code>new</code>, <code>set_status</code> and <code>get_status</code>. We'll ignore <code>new</code> for now as we dive deeper into it in a different tutorial. Let's focus on the other two for now:</p> <ul> <li> <p><code>set_status</code>: enables users to save a message. When this function is called, it first retrieves the account ID of the user who called the contract by using the <code>env::predecessor_account_id()</code> command. To put it simply, this command works similarly to <code>msg.sender</code> in Ethereum and Solidity. Once the account ID is obtained, the <code>records</code> map is updated by associating the message with the corresponding account ID.</p> </li> <li> <p><code>get_status</code>: allows users to retrieve the message for any account by simply passing the <code>account_id</code> of that specific account. Note that in case the <code>account_id</code> key is not present in the map, <code>self.records.get(...)</code> will return <code>None</code>. For more information about the <code>Option</code> type, please refer here.</p> </li> </ul>"},{"location":"execution/#submitting-a-new-transaction","title":"Submitting a new transaction","text":"<p>Users submit signed transactions. For the scope of this tutorial, we will ignore how a transaction is routed to a chunk-producer. Transactions specify batches of Actions. These actions are strictly ordered, an action is executed only if the previous action has been completed. Moreover there is no guarantee that no other action submitted by other accounts will not be executed between the actions in the batch.</p> <p>To execute a function call, a user needs to specify a <code>FunctionCall</code> action. The <code>FunctionCall</code> Action is translated into an <code>ActionReceipt</code>. Receipts are a fundamental component of the NEAR protocol. Shards communicate using receipts. Developers familiar with Ethereum should consider NEAR receipts to be similar to Ethereum transactions, in the sense that they are executed atomically. However, any subsequent cross-contract calls produced are not executed atomically, since they are asynchronous and will execute at the earliest in the next block. Receipts are also different from Ethereum since end users cannot produce receipts, only validators can.</p> <pre><code>ActionReceipt {\nid: \"A1\",\nsigner_id: \"alice\",\nsigner_public_key: \"6934...e248\",\nreceiver_id: \"status-message\",\npredecessor_id: \"alice\",\ninput_data_ids: [],\noutput_data_receivers: [],\nactions: [FunctionCall { gas: 100000, deposit: 0, method_name: \"set_status\", args: \"{'hello_world'}\" }],\n}\n</code></pre>"},{"location":"execution/#executing-an-actionreceipt","title":"Executing an <code>ActionReceipt</code>","text":"<p>Each contract is stored in the form of WebAssembly (WASM for short). The contract is essentially executed by WASMER which is a runtime for WASM. WASMER is wrapped by NEAR's runtime. WASM is to Rust or AssemblyScript what EVM bytecode is to Solidity smart contracts.</p>"},{"location":"execution/#near-runtime","title":"NEAR runtime","text":"<p>The runtime can be regarded as an interpreter for WASM which is allowed to interact with the environment. The WASM representation imports external functions which are executed by the NEAR runtime. For example, in the text representation (called WAT) of the <code>status-message</code> contract we will find the following command:</p> <pre><code>(import \"env\" \"signer_account_id\" (func $env.signer_account_id (type $t5)))\n</code></pre> <p>This command lets the WASM runtime know that the a <code>signer_account_id</code> call will be executed by the environment.</p> <p>We can also find calls like the following:</p> <pre><code>(call $env.signer_account_id (i64.const -3))\n</code></pre> <p>This command is essentially a call to the environment. This means that the WASM execution will stop so that the host receives this call and executes it. In this particular case, the host will retrieve the <code>account_id</code> of the signer of this transaction.</p>"},{"location":"execution/#wasm-entry-points","title":"WASM entry points","text":"<p>An important distinction should be made between an EVM smart contract and a WASM contract. WASM smart contracts can have multiple entry points. The entry points are essentially the public functions of the smart contracts. These can be called by the NEAR runtime. The WASM command below exposes the <code>get_status</code> function to the runtime:</p> <pre><code>(func $get_status (export \"get_status\") (type $t11) ...\n</code></pre> <p>An observant reader of the WASM bytecode might notice that neither <code>set_status</code> nor <code>get_status</code> accept parameters on the WASM level. This is counter-intuitive given that both functions accept arguments on the Rust level. We further explore this in the next section.</p>"},{"location":"execution/#the-near_bindgen-macro","title":"The <code>#[near_bindgen]</code> macro","text":"<p>According to the <code>near-sdk-rs</code> documentation, the <code>#[near_bindgen]</code> macro should always be present to generate the necessary glue code for a valid NEAR contract. In this section, we dive deeper into its functionality.</p> <p>Users can inspect the Rust code with the expanded macros by using <code>cargo-expand</code>. In the resulting code we can find the following:</p> <pre><code>...\n\n#[cfg(target_arch = \"wasm32\")]\n#[no_mangle]\npub extern \"C\" fn set_status() {\nnear_sdk::env::setup_panic_hook();\n#[serde(crate = \"near_sdk::serde\")]\nstruct Input {\nmessage: String,\n}\n#[doc(hidden)]\n#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]\nconst _: () = {...};\nlet Input { message }: Input = near_sdk::serde_json::from_slice(\n&amp;near_sdk::env::input().expect(\"Expected input since method has arguments.\"),\n)\n.expect(\"Failed to deserialize input from JSON.\");\nlet mut contract: StatusMessage = near_sdk::env::state_read().unwrap_or_default();\ncontract.set_status(message);\nnear_sdk::env::state_write(&amp;contract);\n}\n\n#[cfg(target_arch = \"wasm32\")]\n#[no_mangle]\npub extern \"C\" fn get_status() {\n...\n}\n</code></pre> <p>By looking at this snippet we can validate that neither of the exported functions <code>set_status</code> and <code>get_status</code> actually accept arguments. They wrap the actual functions we defined inside <code>impl StatusMessage</code>. We note that the <code>Input</code> struct indeed contains the message. In <code>get_status</code> it contains <code>account_id</code>. Moreover, there are two calls to the environment, one to retrieve the actual input (<code>env::input</code>) and one to get the structure which corresponds to the contract state (<code>env::state_read()</code>). After the execution terminates, the resulting state of the contract is written to persistent memory (<code>env::state_write(&amp;contract)</code>).</p>"},{"location":"gas/","title":"Gas","text":"<p>Gas is the measure of computational effort performed by the validators to execute a receipt. The signer of a receipt must provide enough gas to offset the cost of executing it. There are various fees associated with different operations. For example, creating an action receipt from a transaction incurs the <code>action_receipt_creation_config</code> fee. Each type of action contained in this action receipt will also incur a cost, e.g. the <code>create_account_cost</code> if the action is a CreateAccountAction. The cost of each operation is defined in the <code>GenesisConfig</code>.</p>"},{"location":"gas/#fees","title":"Fees","text":"<p>A fee consists of three different values: <code>send_sir</code>, <code>send_not_sir</code> and <code>execute</code>. The abbreviation <code>sir</code> stands for \"Sender is Receiver\", indicating that a contract is calling itself, e.g. for a callback. The <code>send_sir</code> cost is the fee for sending an object from a sender to themselves. This guarantees staying in the same shard. The <code>send_not_sir</code> cost is the fee for sending an object to an arbitrary receiver, potentially in another shard. The <code>execute</code> cost is the fee for executing the object, which may happen at a different time than sending the object.</p>"},{"location":"gas/#execution-costs","title":"Execution Costs","text":"<p>During the execution of a receipt, other costs can occur. Each interaction with the environment can have one or multiple costs associated with it. For example in the case of <code>storage_write</code>, there is a base cost <code>storage_write_base</code>, a cost per byte of the key <code>storage_write_key_byte</code> and a cost per byte of the value <code>storage_write_value_byte</code>. If there was a previous value, it incurs a cost per byte <code>storage_write_evicted_byte</code>, and the cost of writing it to a register. Lastly, there is a cost associated with the number of trie nodes that were interacted with <code>touching_trie_node</code>.</p> <p>Additionally, each additional receipt produced by the execution incurs a direct cost of creating the receipt, as well as attaching the gas to the receipt for the receiver to use. Note that one must know in advance how much gas to attach to each cross-contract call, one can't simply attach the remaining gas at the end of execution.</p> <p>The execution of WASM code itself is not as easy to translate into gas costs. The runtime injects some gas metering functionality into the WASM code, which accrues the gas costs as they occur during execution.</p>"},{"location":"gas/#gas-refund","title":"Gas Refund","text":"<p>When execution of a receipt terminates, any gas left over is refunded to the signer of the receipt. Note that the signer may be in a different shard, so a refund ActionReceipt must be sent. For the special case of refunds, the <code>signer_id</code> is <code>system</code> and the public key is <code>0</code>. If the receipt was sent using an access key with <code>FunctionCallPermission</code> and limited allowance, the allowance will still be refunded.</p>"},{"location":"gas/#wasm-metering","title":"WASM metering","text":"<p>The <code>wasm_runner</code> and <code>wasmtime_runner</code> use <code>pwasm</code> to inject a gas meter which calls the <code>gas</code> function here. It essentially analyzes the 'basic blocks' of the WASM code and inserts calls to the <code>gas</code> function at the start of each one, to make sure the runtime has enough gas left to execute the entire block. So it's the runtime's responsibility to revert if too much gas is used. The gas costs are configurable, but NEAR seems to use the default values.</p> <p>The <code>wasm2_runner</code> uses custom wasm crates which use a FastGasCounter struct which contains a <code>gas_limit</code>. If this limit is exceeded, an exception occurs and the WASM code stops executing. </p>"},{"location":"issues/","title":"Common Issues","text":"<p>In this section, we present some common pitfalls developers and auditors should keep in mind when working with NEAR smart contracts.</p>"},{"location":"issues/#million-cheap-data-additions","title":"\"million cheap data additions\"","text":"<p>As we explained in a previous tutorial, NEAR introduces storage staking. This means that contracts should lock NEAR tokens when they use the storage. This gives rise to new attack vectors. In particular, for contracts that pay their own fees, a malicious user could repeatedly make cheap calls to a contract. This could lead the contract to a state which it cannot further interact with the storage since it does not hold enough funds, rendering it useless.</p>"},{"location":"issues/#arithmetic-issues-overflows-rounding-errors","title":"Arithmetic issues: Overflows, rounding errors","text":"<p>Rust contracts are only allowed to use integers. Division operation between integers can lead to loss of precision (e.g., <code>2/3=0</code>) and lead contracts to unexpected state. Moreover, rounding errors can accumulate. Like Ethereum, integers have a specified size, thus, operations can lead to overflows. It is important for users to know that overflows will only lead the execution to abort in debug mode. A specific flag must be passed to the compiler to avoid such overflows in release mode. In <code>Cargo.toml</code> add:</p> <pre><code>[profile.release]\noverflow-checks = true\n</code></pre>"},{"location":"issues/#the-prefixes-of-persistent-storage-should-be-different","title":"The prefixes of persistent storage should be different","text":"<p>As we explained when we talked about storage, in NEAR we should specify a prefix for each data structure we use. These prefixes should be guaranteed to different for different data structures otherwise unexpected behavior will arise. Additionally, the prefixes should not be substrings of one another - for example a map with the prefix \"ab\" could have storage slot conflicts with a map with the prefix \"abc\".</p>"},{"location":"issues/#calls-executed-in-multiple-blocks","title":"Calls executed in multiple blocks","text":"<p>A contract method might include cross-contract calls. When a cross-contract call happens, the execution of the contract method halts and awaits completion of the cross-contract call. This means that more calls to the same contract (and even the same method) can take place while the original call is waiting for the cross-contract call to complete. Moreover, as we have already discussed, only action receipts are executed atomically and only the state changes within one action receipt can revert. </p> <p>Similarly, a cross-contract call to a token contract querying the balance of a user does not give any guarantees that the balance will be the same when the cross-contract call returns to the original caller.</p>"},{"location":"issues/#handling-errors-on-cross-contract-calls","title":"Handling Errors on Cross-contract Calls","text":"<p>On NEAR only <code>ActionReceipts</code> are executed atomically. This means that a cross-contract call which reverts will not automatically lead to the revert of the state of the caller. Contracts that make cross-contract calls are responsible for implementing callbacks which manually revert the state should the cross-contract call fail.</p>"},{"location":"issues/#having-enough-gas","title":"Having enough gas","text":"<p>In the previous pitfall, we discussed that contracts should manually handle errors in the cross-contract calls. To do so, they should provide guarantees that there is always enough gas to revert their state. These checks should be performed before a cross-contract call.</p>"},{"location":"issues/#return-values-are-not-typechecked","title":"Return values are not typechecked","text":"<p>Rust is a strongly typed language. This can give the illusion to users that more things are checked during the compilation than they actually are. A good example for that is the return type of callbacks.</p> <p>In the cross-contract call example, <code>handle_callback</code> assumes that the return value is of a given type. However, a call to an arbitrary contract gives no guarantees about the actual type of the data returned. For example a call to an arbitrary contract might return an string while an integer is expected by the callback. This would lead the callback to revert since the decoding would fail.</p>"},{"location":"issues/#the-type-system-doesnt-check-for-appropriate-number-of-promises","title":"The type system doesn't check for appropriate number of Promises","text":"<p>Similarly to the previous issue, there are no checks on how many promises a callback should expect before it executes. The impact of this is the following: A callback might depend on two promises but might be defined to accept three promises. This means that when it is executed, it will try to read a promise that does not exist and thus, fail.</p>"},{"location":"issues/#when-to-use-u64-vs-u64","title":"When to use U64 vs u64","text":"<p>NEAR Protocol currently expects contracts to support JSON serialization. JSON can't handle large integers (above <code>2**53</code> bits). In order to support u64 and u128 integers users should make use of the serializable version of them, namely U64 and U128. <code>near_sdk::json_types</code> supports the conversion between U64 and u64, as well as between U128 and u128. You can refer to <code>near-sdk-docs</code>  for more.</p>"},{"location":"rainbow-bridge/","title":"Rainbow bridge","text":"<p>The rainbow bridge is a bridge between Ethereum and NEAR. In this document we'll give a detailed description of the various parts of the bridge.</p> <p>The overview is based on https://near.org/blog/eth-near-rainbow-bridge/?utm_source=pocket_mylist.</p> <p>Trust assumptions:     * On Ethereum, finality is achieved after X blocks.     * On NEAR, 2/3 of the validators are honest.     * A signature check on Ethereum fits into one block?.</p> <p>The rainbow bridge is:     * trustless: since most of its parts are on blockchain     * rapid: With the exception of checking some signatures on-chain, all the other transactions do not require long time intervals to be executed.     * decentralized: the bridge can be deployed by anyone     * generic: it can be used for different tasks sicne ...</p> <p>Design</p> <p>The system consists of the following smart contracts:</p> <p>On Ethereum:</p> <pre><code>NearBridge: this contract is also known as the NEAR light client. The main purpose of the contract is to track the state of NEAR on Ethereum. Any user who has deposited 32ETH? can submit a new NEAR block (``addLightClientBlock``). At least one block per epoch must be submitted. At the beginning of each epoch the public keys of the validators are saved. To reduce the costs, only the header of the block is added.\n\nThe blocks are sent using the NEAR2ETH relay.\n\nNEAR uses Ed25519 to sign messages. There is no available precompiled contract for EVM to verify the signature, thus, the verification should be using normal contracts. This verification is computationally expensive. To avoid using it, an optimistic approach is chosen. This means any user can challenge a submitted signature by calling ``challenge``. Only the last submitter can be challenged. Currently the challenge window is set to be 4 hours.\n\nNEAROnEthereumProver: It proves the specific events are included?\n\nERC20 Locker: It's responsible for locking and unlocking ERC20 tokens.\n</code></pre> <p>On NEAR:     Ethereum Light Client (eth-client): this contract serves the same role as the near light client on Ethereum. A block is added by calling <code>add_block_header</code>. The ethereum client is more complicated since it has to restrict the storage it occupies on the blockchain. That's why hashes that are too old are removed. </p> <p>Execution Flow</p> <p>From Ethereum to NEAR</p> <pre><code>1. Alice calls ERC20Locker.lockTokens after she has approved the contract. This way she transfers an amount of an ERC20 to the ERC20Locker contract. A locked event is emitted.\n\n2. The relay waits for enough blocks to be confirmed and then pushes the header of the block that contains the event of interest (not entirely precise)\n\n3. RainbowLib computes the proof of the event\n\n4. MintableFungibleToken contract verifies the proof (?)\n\n5. MintableFungibleToken mints the ERC20 token (?)\n</code></pre>"},{"location":"resources/","title":"Resources","text":"<p>Here we have collected material we strongly encourage to review. In our tutorials, we point to some of these resouces.</p> <ul> <li>NEAR docs: A good brief introduction to NEAR concepts.</li> <li>NEAR Specification: The specification of the NEAR protocol.</li> <li>NEAR-SDK: The documentation of the NEAR-SDK.</li> <li>NEAR University: Various tutorials for NEAR.</li> <li>NEAR YouTube Channel: The YouTube channel of NEAR. We strongly recommend the NEAR Core playlist for users who want to dive deep into the protocol.</li> </ul>"},{"location":"resources/#repositories","title":"Repositories:","text":"<ul> <li>near-sdk-rs: The rust implementation of the NEAR SDK. </li> <li>nearcore: The implementation of the NEAR runtime.</li> </ul>"},{"location":"storage/","title":"Storage","text":"<p>In our previous tutorial, we used a <code>HashMap</code> implemented by Rust's standard library when we implemented the <code>status-message</code> contract. In this tutorial we will explore how this map persists in memory, as well as how we can use the <code>collections</code> library offered by <code>near-sdk</code>.</p>"},{"location":"storage/#tries","title":"Tries","text":"<p>The state of the NEAR blockchain is stored in a Merkle Patricia Trie. For the scope of this tutorial, we consider a simple trie and we will ignore the technical details of Patricia tries. Hence, we should think of a trie as a tree which stores data in its leaves and each node corresponds to one byte of its key. This means that in order to access the data for a specific key, we need to follow the nodes that comprise that key. Each account can access only its own state, which is the subtree we end up in if we traverse the state trie using the account id.</p>"},{"location":"storage/#storage-in-wasm","title":"Storage in WASM","text":"<p>The storage of a contract is a key-value store. Both the key and value can be arbitrarily large, but there is a cost associated with the size of each. A contract's state is serialized and stored with the <code>\"STATE\"</code> key.</p> <p>The state of the contract is stored in the state trie. When a function that reads or writes state is called (i.e. it takes <code>&amp;self</code> or <code>&amp;mut self</code> as an argument), the state of the contract is loaded. The state of the contract includes the values of all its field variables. This means that a potentially big data structure like a <code>HashMap</code> is eagerly loaded from storage at this point. This is inefficient, as it requires a lot of computation cycles which results in expensive transactions.</p>"},{"location":"storage/#near_sdkcollections","title":"<code>near_sdk::collections</code>","text":"<p>An alternative is to store the big data structure using many different keys and only store a reference to this structure in the contract's state. This is exactly what the <code>near_sdk::collections</code> library allows us to do. This way we can access and modify data structures more efficiently. In order to do so we need to assign a unique prefix to the data structure. The <code>PersistentMap</code> with prefix <code>prefix</code> would map each of its values to an individual storage value, so each one can be deserialized individually. To do this, the <code>PersistentMap</code> prepends its prefix to the provided key and simply stores the value using this storage key. For example, putting a value with key <code>\"key\"</code> in the map would actually store the value in the contract's storage using the key <code>\"prefixkey\"</code>. This differs from a <code>HashMap</code>, which instead would have to serialize and deserialize its entire contents each time the contract state is read or written. Note that this does mean it's possible for different maps to write to the same storage key. Additionally, there is a cost associated with the length of the storage key, so using a short prefix is a good idea.</p>"},{"location":"storage/#storage-staking","title":"Storage Staking","text":"<p>A contract must stake NEAR tokens for the storage it occupies. This means that contracts pay for storage and cannot store additional values unless they have enough NEAR tokens. Whether or not a contract has staked enough tokens for its balance is checked at the end of each action. This staking for storage should not be confused with users paying for the execution of a smart contract.</p>"}]}